//<auto-generated />
// ReSharper disable once CheckNamespace
namespace Dapper
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Linq;
    using System.Threading.Tasks;

    /// <summary>
    /// Dapper, a light weight object mapper for ADO.NET.
    /// </summary>
    /// <remarks>
    /// Extensions metods para dapper que encapsulan la misma funcionalidad de dapper pero si se produce
    /// una excepción las procesa para convertirlas a excepciones core.
    /// </remarks>
    public static class SqlMapperExtensions
    {
        /// <summary>Execute a query asynchronously using .NET 4.5 Task.</summary>
        /// <remarks>Note: each row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
        public static Task<IEnumerable<object>> QueryAsyncAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return cnn.QueryAsync(sql, param, transaction, commandTimeout, commandType).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Execute a query asynchronously using .NET 4.5 Task.</summary>
        /// <remarks>Note: each row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
        public static Task<IEnumerable<object>> QueryAsyncAndThrow(this IDbConnection cnn, CommandDefinition command)
        {
            return cnn.QueryAsync(command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        /// <remarks>Note: the row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
        public static Task<object> QueryFirstAsyncAndThrow(this IDbConnection cnn, CommandDefinition command)
        {
            return cnn.QueryFirstAsync(command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        /// <remarks>Note: the row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
        public static Task<object> QueryFirstOrDefaultAsyncAndThrow(this IDbConnection cnn, CommandDefinition command)
        {
            return cnn.QueryFirstOrDefaultAsync(command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        /// <remarks>Note: the row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
        public static Task<object> QuerySingleAsyncAndThrow(this IDbConnection cnn, CommandDefinition command)
        {
            return cnn.QuerySingleAsync(command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        /// <remarks>Note: the row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
        public static Task<object> QuerySingleOrDefaultAsyncAndThrow(this IDbConnection cnn, CommandDefinition command)
        {
            return cnn.QuerySingleOrDefaultAsync(command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Execute a query asynchronously using .NET 4.5 Task.</summary>
        public static Task<IEnumerable<T>> QueryAsyncAndThrow<T>(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return cnn.QueryAsync<T>(sql, param, transaction, commandTimeout, commandType).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation<T>(ex, sql, param, transaction, commandTimeout, commandType);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        public static Task<T> QueryFirstAsyncAndThrow<T>(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return cnn.QueryFirstAsync<T>(sql, param, transaction, commandTimeout, commandType).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation<T>(ex, sql, param, transaction, commandTimeout, commandType);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        public static Task<T> QueryFirstOrDefaultAsyncAndThrow<T>(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return
                cnn.QueryFirstOrDefaultAsync<T>(sql, param, transaction, commandTimeout, commandType).ContinueWith(
                    t =>
                    {
                        if (t.IsFaulted)
                        {
                            Exception ex = ExceptionManager.Process(cnn, t.Exception);
                            AddInformation<T>(ex, sql, param, transaction, commandTimeout, commandType);
                            throw ex;
                        }

                        return t.Result;
                    },
                    TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        public static Task<T> QuerySingleAsyncAndThrow<T>(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return cnn.QuerySingleAsync<T>(sql, param, transaction, commandTimeout, commandType).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation<T>(ex, sql, param, transaction, commandTimeout, commandType);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        public static Task<T> QuerySingleOrDefaultAsyncAndThrow<T>(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return
                cnn.QuerySingleOrDefaultAsync<T>(sql, param, transaction, commandTimeout, commandType).ContinueWith(
                    t =>
                    {
                        if (t.IsFaulted)
                        {
                            Exception ex = ExceptionManager.Process(cnn, t.Exception);
                            AddInformation<T>(ex, sql, param, transaction, commandTimeout, commandType);
                            throw ex;
                        }

                        return t.Result;
                    },
                    TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Execute a query asynchronously using .NET 4.5 Task.</summary>
        public static Task<IEnumerable<object>> QueryAsyncAndThrow(
            this IDbConnection cnn,
            Type type,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return cnn.QueryAsync(sql, param, transaction, commandTimeout, commandType).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        public static Task<object> QueryFirstAsyncAndThrow(
            this IDbConnection cnn,
            Type type,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return cnn.QueryFirstAsync(type, sql, param, transaction, commandTimeout, commandType).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, type, sql, param, transaction, commandTimeout, commandType);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        public static Task<object> QueryFirstOrDefaultAsyncAndThrow(
            this IDbConnection cnn,
            Type type,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return
                cnn.QueryFirstOrDefaultAsync(type, sql, param, transaction, commandTimeout, commandType)
                    .ContinueWith(
                        t =>
                        {
                            if (t.IsFaulted)
                            {
                                Exception ex = ExceptionManager.Process(cnn, t.Exception);
                                AddInformation(ex, type, sql, param, transaction, commandTimeout, commandType);
                                throw ex;
                            }

                            return t.Result;
                        },
                        TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        public static Task<object> QuerySingleAsyncAndThrow(
            this IDbConnection cnn,
            Type type,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return cnn.QuerySingleAsync(type, sql, param, transaction, commandTimeout, commandType).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, type, sql, param, transaction, commandTimeout, commandType);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        public static Task<object> QuerySingleOrDefaultAsyncAndThrow(
            this IDbConnection cnn,
            Type type,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return
                cnn.QuerySingleOrDefaultAsync(type, sql, param, transaction, commandTimeout, commandType)
                    .ContinueWith(
                        t =>
                        {
                            if (t.IsFaulted)
                            {
                                Exception ex = ExceptionManager.Process(cnn, t.Exception);
                                AddInformation(ex, type, sql, param, transaction, commandTimeout, commandType);
                                throw ex;
                            }

                            return t.Result;
                        },
                        TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Execute a query asynchronously using .NET 4.5 Task.</summary>
        public static Task<IEnumerable<T>> QueryAsyncAndThrow<T>(this IDbConnection cnn, CommandDefinition command)
        {
            return cnn.QueryAsync<T>(command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation<T>(ex, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Execute a query asynchronously using .NET 4.5 Task.</summary>
        public static Task<IEnumerable<object>> QueryAsyncAndThrow(
            this IDbConnection cnn,
            Type type,
            CommandDefinition command)
        {
            return cnn.QueryAsync(type, command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, type, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        public static Task<object> QueryFirstAsyncAndThrow(this IDbConnection cnn, Type type, CommandDefinition command)
        {
            return cnn.QueryFirstAsync(type, command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, type, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        public static Task<object> QueryFirstOrDefaultAsyncAndThrow(
            this IDbConnection cnn,
            Type type,
            CommandDefinition command)
        {
            return cnn.QueryFirstOrDefaultAsync(type, command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, type, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        public static Task<object> QuerySingleAsyncAndThrow(
            this IDbConnection cnn,
            Type type,
            CommandDefinition command)
        {
            return cnn.QuerySingleAsync(type, command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, type, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a single-row query asynchronously using .NET 4.5 Task.
        /// </summary>
        public static Task<object> QuerySingleOrDefaultAsyncAndThrow(
            this IDbConnection cnn,
            Type type,
            CommandDefinition command)
        {
            return cnn.QuerySingleOrDefaultAsync(type, command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, type, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Execute a command asynchronously using .NET 4.5 Task.</summary>
        public static Task<int> ExecuteAsyncAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return cnn.ExecuteAsync(sql, param, transaction, commandTimeout, commandType).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Execute a command asynchronously using .NET 4.5 Task.</summary>
        public static Task<int> ExecuteAsyncAndThrow(this IDbConnection cnn, CommandDefinition command)
        {
            return cnn.ExecuteAsync(command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Maps a query to objects</summary>
        /// <typeparam name="TFirst">The first type in the recordset</typeparam>
        /// <typeparam name="TSecond">The second type in the recordset</typeparam>
        /// <typeparam name="TReturn">The return type</typeparam>
        /// <param name="cnn"></param>
        /// <param name="sql"></param>
        /// <param name="map"></param>
        /// <param name="param"></param>
        /// <param name="transaction"></param>
        /// <param name="buffered"></param>
        /// <param name="splitOn">The field we should split and read the second object from (default: id)</param>
        /// <param name="commandTimeout">Number of seconds before command execution timeout</param>
        /// <param name="commandType">Is it a stored proc or a batch?</param>
        /// <returns></returns>
        public static Task<IEnumerable<TReturn>> QueryAsyncAndThrow<TFirst, TSecond, TReturn>(
            this IDbConnection cnn,
            string sql,
            Func<TFirst, TSecond, TReturn> map,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            string splitOn = "Id",
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return
                cnn.QueryAsync(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType)
                    .ContinueWith(
                        t =>
                        {
                            if (t.IsFaulted)
                            {
                                Exception ex = ExceptionManager.Process(cnn, t.Exception);
                                AddInformation(
                                    ex,
                                    sql,
                                    map,
                                    param,
                                    transaction,
                                    buffered,
                                    splitOn,
                                    commandTimeout,
                                    commandType);
                                throw ex;
                            }

                            return t.Result;
                        },
                        TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Maps a query to objects</summary>
        /// <typeparam name="TFirst">The first type in the recordset</typeparam>
        /// <typeparam name="TSecond">The second type in the recordset</typeparam>
        /// <typeparam name="TReturn">The return type</typeparam>
        /// <param name="cnn"></param>
        /// <param name="splitOn">The field we should split and read the second object from (default: id)</param>
        /// <param name="command">The command to execute</param>
        /// <param name="map"></param>
        /// <returns></returns>
        public static Task<IEnumerable<TReturn>> QueryAsyncAndThrow<TFirst, TSecond, TReturn>(
            this IDbConnection cnn,
            CommandDefinition command,
            Func<TFirst, TSecond, TReturn> map,
            string splitOn = "Id")
        {
            return cnn.QueryAsync(command, map, splitOn).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command, map, splitOn);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Maps a query to objects</summary>
        /// <typeparam name="TFirst"></typeparam>
        /// <typeparam name="TSecond"></typeparam>
        /// <typeparam name="TThird"></typeparam>
        /// <typeparam name="TReturn"></typeparam>
        /// <param name="cnn"></param>
        /// <param name="sql"></param>
        /// <param name="map"></param>
        /// <param name="param"></param>
        /// <param name="transaction"></param>
        /// <param name="buffered"></param>
        /// <param name="splitOn">The Field we should split and read the second object from (default: id)</param>
        /// <param name="commandTimeout">Number of seconds before command execution timeout</param>
        /// <param name="commandType"></param>
        /// <returns></returns>
        public static Task<IEnumerable<TReturn>> QueryAsyncAndThrow<TFirst, TSecond, TThird, TReturn>(
            this IDbConnection cnn,
            string sql,
            Func<TFirst, TSecond, TThird, TReturn> map,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            string splitOn = "Id",
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return
                cnn.QueryAsync(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType)
                    .ContinueWith(
                        t =>
                        {
                            if (t.IsFaulted)
                            {
                                Exception ex = ExceptionManager.Process(cnn, t.Exception);
                                AddInformation(
                                    ex,
                                    sql,
                                    map,
                                    param,
                                    transaction,
                                    buffered,
                                    splitOn,
                                    commandTimeout,
                                    commandType);
                                throw ex;
                            }

                            return t.Result;
                        },
                        TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Maps a query to objects</summary>
        /// <typeparam name="TFirst"></typeparam>
        /// <typeparam name="TSecond"></typeparam>
        /// <typeparam name="TThird"></typeparam>
        /// <typeparam name="TReturn"></typeparam>
        /// <param name="cnn"></param>
        /// <param name="splitOn">The field we should split and read the second object from (default: id)</param>
        /// <param name="command">The command to execute</param>
        /// <param name="map"></param>
        /// <returns></returns>
        public static Task<IEnumerable<TReturn>> QueryAsyncAndThrow<TFirst, TSecond, TThird, TReturn>(
            this IDbConnection cnn,
            CommandDefinition command,
            Func<TFirst, TSecond, TThird, TReturn> map,
            string splitOn = "Id")
        {
            return cnn.QueryAsync(command, map, splitOn).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command, map, splitOn);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Perform a multi mapping query with 4 input parameters</summary>
        /// <typeparam name="TFirst"></typeparam>
        /// <typeparam name="TSecond"></typeparam>
        /// <typeparam name="TThird"></typeparam>
        /// <typeparam name="TFourth"></typeparam>
        /// <typeparam name="TReturn"></typeparam>
        /// <param name="cnn"></param>
        /// <param name="sql"></param>
        /// <param name="map"></param>
        /// <param name="param"></param>
        /// <param name="transaction"></param>
        /// <param name="buffered"></param>
        /// <param name="splitOn"></param>
        /// <param name="commandTimeout"></param>
        /// <param name="commandType"></param>
        /// <returns></returns>
        public static Task<IEnumerable<TReturn>> QueryAsyncAndThrow<TFirst, TSecond, TThird, TFourth, TReturn>(
            this IDbConnection cnn,
            string sql,
            Func<TFirst, TSecond, TThird, TFourth, TReturn> map,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            string splitOn = "Id",
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return
                cnn.QueryAsync(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType)
                    .ContinueWith(
                        t =>
                        {
                            if (t.IsFaulted)
                            {
                                Exception ex = ExceptionManager.Process(cnn, t.Exception);
                                AddInformation(
                                    ex,
                                    sql,
                                    map,
                                    param,
                                    transaction,
                                    buffered,
                                    splitOn,
                                    commandTimeout,
                                    commandType);
                                throw ex;
                            }

                            return t.Result;
                        },
                        TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Perform a multi mapping query with 4 input parameters</summary>
        /// <typeparam name="TFirst"></typeparam>
        /// <typeparam name="TSecond"></typeparam>
        /// <typeparam name="TThird"></typeparam>
        /// <typeparam name="TFourth"></typeparam>
        /// <typeparam name="TReturn"></typeparam>
        /// <param name="cnn"></param>
        /// <param name="splitOn">The field we should split and read the second object from (default: id)</param>
        /// <param name="command">The command to execute</param>
        /// <param name="map"></param>
        /// <returns></returns>
        public static Task<IEnumerable<TReturn>> QueryAsyncAndThrow<TFirst, TSecond, TThird, TFourth, TReturn>(
            this IDbConnection cnn,
            CommandDefinition command,
            Func<TFirst, TSecond, TThird, TFourth, TReturn> map,
            string splitOn = "Id")
        {
            return cnn.QueryAsync(command, map, splitOn).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command, map, splitOn);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Perform a multi mapping query with 5 input parameters</summary>
        public static Task<IEnumerable<TReturn>> QueryAsyncAndThrow<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(
            this IDbConnection cnn,
            string sql,
            Func<TFirst, TSecond, TThird, TFourth, TFifth, TReturn> map,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            string splitOn = "Id",
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return
                cnn.QueryAsync(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType)
                    .ContinueWith(
                        t =>
                        {
                            if (t.IsFaulted)
                            {
                                Exception ex = ExceptionManager.Process(cnn, t.Exception);
                                AddInformation(
                                    ex,
                                    sql,
                                    map,
                                    param,
                                    transaction,
                                    buffered,
                                    splitOn,
                                    commandTimeout,
                                    commandType);
                                throw ex;
                            }

                            return t.Result;
                        },
                        TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Perform a multi mapping query with 5 input parameters</summary>
        public static Task<IEnumerable<TReturn>> QueryAsyncAndThrow<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(
            this IDbConnection cnn,
            CommandDefinition command,
            Func<TFirst, TSecond, TThird, TFourth, TFifth, TReturn> map,
            string splitOn = "Id")
        {
            return cnn.QueryAsync(command, map, splitOn).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command, map, splitOn);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Perform a multi mapping query with 6 input parameters</summary>
        public static Task<IEnumerable<TReturn>> QueryAsyncAndThrow
            <TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn>(
                this IDbConnection cnn,
                string sql,
                Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn> map,
                object param = null,
                IDbTransaction transaction = null,
                bool buffered = true,
                string splitOn = "Id",
                int? commandTimeout = null,
                CommandType? commandType = null)
        {
            return
                cnn.QueryAsync(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType)
                    .ContinueWith(
                        t =>
                        {
                            if (t.IsFaulted)
                            {
                                Exception ex = ExceptionManager.Process(cnn, t.Exception);
                                AddInformation(
                                    ex,
                                    sql,
                                    map,
                                    param,
                                    transaction,
                                    buffered,
                                    splitOn,
                                    commandTimeout,
                                    commandType);
                                throw ex;
                            }

                            return t.Result;
                        },
                        TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Perform a multi mapping query with 6 input parameters</summary>
        public static Task<IEnumerable<TReturn>> QueryAsyncAndThrow
            <TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn>(
                this IDbConnection cnn,
                CommandDefinition command,
                Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn> map,
                string splitOn = "Id")
        {
            return cnn.QueryAsync(command, map, splitOn).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command, map, splitOn);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Perform a multi mapping query with 7 input parameters</summary>
        public static Task<IEnumerable<TReturn>> QueryAsyncAndThrow
            <TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn>(
                this IDbConnection cnn,
                string sql,
                Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn> map,
                object param = null,
                IDbTransaction transaction = null,
                bool buffered = true,
                string splitOn = "Id",
                int? commandTimeout = null,
                CommandType? commandType = null)
        {
            return
                cnn.QueryAsync(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType)
                    .ContinueWith(
                        t =>
                        {
                            if (t.IsFaulted)
                            {
                                Exception ex = ExceptionManager.Process(cnn, t.Exception);
                                AddInformation(
                                    ex,
                                    sql,
                                    map,
                                    param,
                                    transaction,
                                    buffered,
                                    splitOn,
                                    commandTimeout,
                                    commandType);
                                throw ex;
                            }

                            return t.Result;
                        },
                        TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Perform a multi mapping query with 7 input parameters</summary>
        public static Task<IEnumerable<TReturn>> QueryAsyncAndThrow
            <TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn>(
                this IDbConnection cnn,
                CommandDefinition command,
                Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn> map,
                string splitOn = "Id")
        {
            return cnn.QueryAsync(command, map, splitOn).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command, map, splitOn);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Perform a multi mapping query with arbitrary input parameters
        /// </summary>
        /// <typeparam name="TReturn">The return type</typeparam>
        /// <param name="cnn"></param>
        /// <param name="sql"></param>
        /// <param name="types">array of types in the recordset</param>
        /// <param name="map"></param>
        /// <param name="param"></param>
        /// <param name="transaction"></param>
        /// <param name="buffered"></param>
        /// <param name="splitOn">The Field we should split and read the second object from (default: id)</param>
        /// <param name="commandTimeout">Number of seconds before command execution timeout</param>
        /// <param name="commandType">Is it a stored proc or a batch?</param>
        /// <returns></returns>
        public static Task<IEnumerable<TReturn>> QueryAsyncAndThrow<TReturn>(
            this IDbConnection cnn,
            string sql,
            Type[] types,
            Func<object[], TReturn> map,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            string splitOn = "Id",
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return
                cnn.QueryAsync(sql, types, map, param, transaction, buffered, splitOn, commandTimeout, commandType)
                    .ContinueWith(
                        t =>
                        {
                            if (t.IsFaulted)
                            {
                                Exception ex = ExceptionManager.Process(cnn, t.Exception);
                                AddInformation(
                                    ex,
                                    sql,
                                    types,
                                    map,
                                    param,
                                    transaction,
                                    buffered,
                                    splitOn,
                                    commandTimeout,
                                    commandType);
                                throw ex;
                            }

                            return t.Result;
                        },
                        TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a command that returns multiple result sets, and access each in turn
        /// </summary>
        public static Task<SqlMapper.GridReader> QueryMultipleAsyncAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return cnn.QueryMultipleAsync(sql, param, transaction, commandTimeout, commandType).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute a command that returns multiple result sets, and access each in turn
        /// </summary>
        public static async Task<SqlMapper.GridReader> QueryMultipleAsyncAndThrow(
            this IDbConnection cnn,
            CommandDefinition command)
        {
            return await cnn.QueryMultipleAsync(command).ContinueWith(
                       t =>
                       {
                           if (t.IsFaulted)
                           {
                               Exception ex = ExceptionManager.Process(cnn, t.Exception);
                               AddInformation(ex, command);
                               throw ex;
                           }

                           return t.Result;
                       },
                       TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute parameterized SQL and return an <see cref="T:System.Data.IDataReader" />
        /// </summary>
        /// <returns>An <see cref="T:System.Data.IDataReader" /> that can be used to iterate over the results of the SQL query.</returns>
        /// <remarks>
        /// This is typically used when the results of a query are not processed by Dapper, for example, used to fill a
        /// <see cref="T:System.Data.DataTable" />
        /// or <see cref="T:DataSet" />.
        /// </remarks>
        /// <example>
        /// <code>
        /// <![CDATA[
        /// DataTable table = new DataTable("MyTable");
        /// using (var reader = ExecuteReader(cnn, sql, param))
        /// {
        /// table.Load(reader);
        /// }
        /// ]]>
        /// </code>
        /// </example>
        public static Task<IDataReader> ExecuteReaderAsyncAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return cnn.ExecuteReaderAsync(sql, param, transaction, commandTimeout, commandType).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>
        /// Execute parameterized SQL and return an <see cref="T:System.Data.IDataReader" />
        /// </summary>
        /// <returns>An <see cref="T:System.Data.IDataReader" /> that can be used to iterate over the results of the SQL query.</returns>
        /// <remarks>
        /// This is typically used when the results of a query are not processed by Dapper, for example, used to fill a
        /// <see cref="T:System.Data.DataTable" />
        /// or <see cref="T:DataSet" />.
        /// </remarks>
        public static Task<IDataReader> ExecuteReaderAsyncAndThrow(this IDbConnection cnn, CommandDefinition command)
        {
            return cnn.ExecuteReaderAsync(command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Execute parameterized SQL that selects a single value</summary>
        /// <returns>The first cell selected</returns>
        public static Task<object> ExecuteScalarAsyncAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return cnn.ExecuteScalarAsync(sql, param, transaction, commandTimeout, commandType).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Execute parameterized SQL that selects a single value</summary>
        /// <returns>The first cell selected</returns>
        public static Task<T> ExecuteScalarAsyncAndThrow<T>(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            return cnn.ExecuteScalarAsync<T>(sql, param, transaction, commandTimeout, commandType).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation<T>(ex, sql, param, transaction, commandTimeout, commandType);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Execute parameterized SQL that selects a single value</summary>
        /// <returns>The first cell selected</returns>
        public static Task<object> ExecuteScalarAsyncAndThrow(this IDbConnection cnn, CommandDefinition command)
        {
            return cnn.ExecuteScalarAsync(command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation(ex, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Execute parameterized SQL that selects a single value</summary>
        /// <returns>The first cell selected</returns>
        public static Task<T> ExecuteScalarAsyncAndThrow<T>(this IDbConnection cnn, CommandDefinition command)
        {
            return cnn.ExecuteScalarAsync<T>(command).ContinueWith(
                t =>
                {
                    if (t.IsFaulted)
                    {
                        Exception ex = ExceptionManager.Process(cnn, t.Exception);
                        AddInformation<T>(ex, command);
                        throw ex;
                    }

                    return t.Result;
                },
                TaskContinuationOptions.RunContinuationsAsynchronously);
        }

        /// <summary>Execute parameterized SQL</summary>
        /// <returns>Number of rows affected</returns>
        public static int ExecuteAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            int ret;
            try
            {
                ret = cnn.Execute(sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>Execute parameterized SQL</summary>
        /// <returns>Number of rows affected</returns>
        public static int ExecuteAndThrow(this IDbConnection cnn, CommandDefinition command)
        {
            int ret;
            try
            {
                ret = cnn.Execute(command);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, command);
                throw ex;
            }

            return ret;
        }

        /// <summary>Execute parameterized SQL that selects a single value</summary>
        /// <returns>The first cell selected</returns>
        public static object ExecuteScalarAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            object ret;
            try
            {
                ret = cnn.ExecuteScalar(sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>Execute parameterized SQL that selects a single value</summary>
        /// <returns>The first cell selected</returns>
        public static T ExecuteScalarAndThrow<T>(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            T ret;
            try
            {
                ret = cnn.ExecuteScalar<T>(sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation<T>(ex, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>Execute parameterized SQL that selects a single value</summary>
        /// <returns>The first cell selected</returns>
        public static object ExecuteScalarAndThrow(this IDbConnection cnn, CommandDefinition command)
        {
            object ret;
            try
            {
                ret = cnn.ExecuteScalar(command);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, command);
                throw ex;
            }

            return ret;
        }

        /// <summary>Execute parameterized SQL that selects a single value</summary>
        /// <returns>The first cell selected</returns>
        public static T ExecuteScalarAndThrow<T>(this IDbConnection cnn, CommandDefinition command)
        {
            T ret;
            try
            {
                ret = cnn.ExecuteScalar<T>(command);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation<T>(ex, command);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Execute parameterized SQL and return an <see cref="T:System.Data.IDataReader" />
        /// </summary>
        /// <returns>An <see cref="T:System.Data.IDataReader" /> that can be used to iterate over the results of the SQL query.</returns>
        /// <remarks>
        /// This is typically used when the results of a query are not processed by Dapper, for example, used to fill a
        /// <see cref="T:System.Data.DataTable" />
        /// or <see cref="T:DataSet" />.
        /// </remarks>
        /// <example>
        /// <code>
        /// <![CDATA[
        /// DataTable table = new DataTable("MyTable");
        /// using (var reader = ExecuteReader(cnn, sql, param))
        /// {
        /// table.Load(reader);
        /// }
        /// ]]>
        /// </code>
        /// </example>
        public static IDataReader ExecuteReaderAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            IDataReader ret;
            try
            {
                ret = cnn.ExecuteReader(sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Execute parameterized SQL and return an <see cref="T:System.Data.IDataReader" />
        /// </summary>
        /// <returns>An <see cref="T:System.Data.IDataReader" /> that can be used to iterate over the results of the SQL query.</returns>
        /// <remarks>
        /// This is typically used when the results of a query are not processed by Dapper, for example, used to fill a
        /// <see cref="T:System.Data.DataTable" />
        /// or <see cref="T:DataSet" />.
        /// </remarks>
        public static IDataReader ExecuteReaderAndThrow(this IDbConnection cnn, CommandDefinition command)
        {
            IDataReader ret;
            try
            {
                ret = cnn.ExecuteReader(command);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, command);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Execute parameterized SQL and return an <see cref="T:System.Data.IDataReader" />
        /// </summary>
        /// <returns>An <see cref="T:System.Data.IDataReader" /> that can be used to iterate over the results of the SQL query.</returns>
        /// <remarks>
        /// This is typically used when the results of a query are not processed by Dapper, for example, used to fill a
        /// <see cref="T:System.Data.DataTable" />
        /// or <see cref="T:DataSet" />.
        /// </remarks>
        public static IDataReader ExecuteReaderAndThrow(
            this IDbConnection cnn,
            CommandDefinition command,
            CommandBehavior commandBehavior)
        {
            IDataReader ret;
            try
            {
                ret = cnn.ExecuteReader(command, commandBehavior);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, command, commandBehavior);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Return a sequence of dynamic objects with properties matching the columns
        /// </summary>
        /// <remarks>Note: each row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
        public static IEnumerable<object> QueryAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            IEnumerable<object> ret;
            try
            {
                ret = cnn.Query(sql, param, transaction, buffered, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, param, transaction, buffered, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Return a dynamic object with properties matching the columns
        /// </summary>
        /// <remarks>Note: the row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
        public static object QueryFirstAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            object ret;
            try
            {
                ret = cnn.QueryFirst(sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Return a dynamic object with properties matching the columns
        /// </summary>
        /// <remarks>Note: the row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
        public static object QueryFirstOrDefaultAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            object ret;
            try
            {
                ret = cnn.QueryFirstOrDefault(sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Return a dynamic object with properties matching the columns
        /// </summary>
        /// <remarks>Note: the row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
        public static object QuerySingleAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            object ret;
            try
            {
                ret = cnn.QuerySingle(sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Return a dynamic object with properties matching the columns
        /// </summary>
        /// <remarks>Note: the row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
        public static object QuerySingleOrDefaultAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            object ret;
            try
            {
                ret = cnn.QuerySingleOrDefault(sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>Executes a query, returning the data typed as per T</summary>
        /// <returns>
        /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first
        /// column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static IEnumerable<T> QueryAndThrow<T>(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            IEnumerable<T> ret;
            try
            {
                ret = cnn.Query<T>(sql, param, transaction, buffered, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation<T>(ex, sql, param, transaction, buffered, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Executes a single-row query, returning the data typed as per T
        /// </summary>
        /// <returns>
        /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first
        /// column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static T QueryFirstAndThrow<T>(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            T ret;
            try
            {
                ret = cnn.QueryFirst<T>(sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation<T>(ex, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Executes a single-row query, returning the data typed as per T
        /// </summary>
        /// <returns>
        /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first
        /// column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static T QueryFirstOrDefaultAndThrow<T>(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            T ret;
            try
            {
                ret = cnn.QueryFirstOrDefault<T>(sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation<T>(ex, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Executes a single-row query, returning the data typed as per T
        /// </summary>
        /// <returns>
        /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first
        /// column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static T QuerySingleAndThrow<T>(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            T ret;
            try
            {
                ret = cnn.QuerySingle<T>(sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation<T>(ex, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Executes a single-row query, returning the data typed as per T
        /// </summary>
        /// <returns>
        /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first
        /// column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static T QuerySingleOrDefaultAndThrow<T>(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            T ret;
            try
            {
                ret = cnn.QuerySingleOrDefault<T>(sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation<T>(ex, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Executes a single-row query, returning the data typed as per the Type suggested
        /// </summary>
        /// <returns>
        /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first
        /// column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static IEnumerable<object> QueryAndThrow(
            this IDbConnection cnn,
            Type type,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            IEnumerable<object> ret;
            try
            {
                ret = cnn.Query(type, sql, param, transaction, buffered, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, type, sql, param, transaction, buffered, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Executes a single-row query, returning the data typed as per the Type suggested
        /// </summary>
        /// <returns>
        /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first
        /// column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static object QueryFirstAndThrow(
            this IDbConnection cnn,
            Type type,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            object ret;
            try
            {
                ret = cnn.QueryFirst(type, sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, type, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Executes a single-row query, returning the data typed as per the Type suggested
        /// </summary>
        /// <returns>
        /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first
        /// column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static object QueryFirstOrDefaultAndThrow(
            this IDbConnection cnn,
            Type type,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            object ret;
            try
            {
                ret = cnn.QueryFirstOrDefault(type, sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, type, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Executes a single-row query, returning the data typed as per the Type suggested
        /// </summary>
        /// <returns>
        /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first
        /// column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static object QuerySingleAndThrow(
            this IDbConnection cnn,
            Type type,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            object ret;
            try
            {
                ret = cnn.QuerySingle(type, sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, type, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Executes a single-row query, returning the data typed as per the Type suggested
        /// </summary>
        /// <returns>
        /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first
        /// column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static object QuerySingleOrDefaultAndThrow(
            this IDbConnection cnn,
            Type type,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            object ret;
            try
            {
                ret = cnn.QuerySingleOrDefault(type, sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, type, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>Executes a query, returning the data typed as per T</summary>
        /// <remarks>
        /// the dynamic param may seem a bit odd, but this works around a major usability issue in vs, if it is Object vs
        /// completion gets annoying. Eg type new [space] get new object
        /// </remarks>
        /// <returns>
        /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first
        /// column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static IEnumerable<T> QueryAndThrow<T>(this IDbConnection cnn, CommandDefinition command)
        {
            IEnumerable<T> ret;
            try
            {
                ret = cnn.Query<T>(command);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation<T>(ex, command);
                throw ex;
            }

            return ret;
        }

        /// <summary>Executes a query, returning the data typed as per T</summary>
        /// <remarks>
        /// the dynamic param may seem a bit odd, but this works around a major usability issue in vs, if it is Object vs
        /// completion gets annoying. Eg type new [space] get new object
        /// </remarks>
        /// <returns>
        /// A single instance or null of the supplied type; if a basic type (int, string, etc) is queried then the data from
        /// the first column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static T QueryFirstAndThrow<T>(this IDbConnection cnn, CommandDefinition command)
        {
            T ret;
            try
            {
                ret = cnn.QueryFirst<T>(command);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation<T>(ex, command);
                throw ex;
            }

            return ret;
        }

        /// <summary>Executes a query, returning the data typed as per T</summary>
        /// <remarks>
        /// the dynamic param may seem a bit odd, but this works around a major usability issue in vs, if it is Object vs
        /// completion gets annoying. Eg type new [space] get new object
        /// </remarks>
        /// <returns>
        /// A single or null instance of the supplied type; if a basic type (int, string, etc) is queried then the data from
        /// the first column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static T QueryFirstOrDefaultAndThrow<T>(this IDbConnection cnn, CommandDefinition command)
        {
            T ret;
            try
            {
                ret = cnn.QueryFirstOrDefault<T>(command);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation<T>(ex, command);
                throw ex;
            }

            return ret;
        }

        /// <summary>Executes a query, returning the data typed as per T</summary>
        /// <remarks>
        /// the dynamic param may seem a bit odd, but this works around a major usability issue in vs, if it is Object vs
        /// completion gets annoying. Eg type new [space] get new object
        /// </remarks>
        /// <returns>
        /// A single instance of the supplied type; if a basic type (int, string, etc) is queried then the data from the first
        /// column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static T QuerySingleAndThrow<T>(this IDbConnection cnn, CommandDefinition command)
        {
            T ret;
            try
            {
                ret = cnn.QuerySingle<T>(command);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation<T>(ex, command);
                throw ex;
            }

            return ret;
        }

        /// <summary>Executes a query, returning the data typed as per T</summary>
        /// <remarks>
        /// the dynamic param may seem a bit odd, but this works around a major usability issue in vs, if it is Object vs
        /// completion gets annoying. Eg type new [space] get new object
        /// </remarks>
        /// <returns>
        /// A single instance of the supplied type; if a basic type (int, string, etc) is queried then the data from the first
        /// column in assumed, otherwise an instance is
        /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
        /// </returns>
        public static T QuerySingleOrDefaultAndThrow<T>(this IDbConnection cnn, CommandDefinition command)
        {
            T ret;
            try
            {
                ret = cnn.QuerySingleOrDefault<T>(command);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation<T>(ex, command);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Execute a command that returns multiple result sets, and access each in turn
        /// </summary>
        public static SqlMapper.GridReader QueryMultipleAndThrow(
            this IDbConnection cnn,
            string sql,
            object param = null,
            IDbTransaction transaction = null,
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            SqlMapper.GridReader ret;
            try
            {
                ret = cnn.QueryMultiple(sql, param, transaction, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Execute a command that returns multiple result sets, and access each in turn
        /// </summary>
        public static SqlMapper.GridReader QueryMultipleAndThrow(this IDbConnection cnn, CommandDefinition command)
        {
            SqlMapper.GridReader ret;
            try
            {
                ret = cnn.QueryMultiple(command);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, command);
                throw ex;
            }

            return ret;
        }

        /// <summary>Maps a query to objects</summary>
        /// <typeparam name="TFirst">The first type in the record set</typeparam>
        /// <typeparam name="TSecond">The second type in the record set</typeparam>
        /// <typeparam name="TReturn">The return type</typeparam>
        /// <param name="cnn"></param>
        /// <param name="sql"></param>
        /// <param name="map"></param>
        /// <param name="param"></param>
        /// <param name="transaction"></param>
        /// <param name="buffered"></param>
        /// <param name="splitOn">The Field we should split and read the second object from (default: id)</param>
        /// <param name="commandTimeout">Number of seconds before command execution timeout</param>
        /// <param name="commandType">Is it a stored proc or a batch?</param>
        /// <returns></returns>
        public static IEnumerable<TReturn> QueryAndThrow<TFirst, TSecond, TReturn>(
            this IDbConnection cnn,
            string sql,
            Func<TFirst, TSecond, TReturn> map,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            string splitOn = "Id",
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            IEnumerable<TReturn> ret;
            try
            {
                ret = cnn.Query(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>Maps a query to objects</summary>
        /// <typeparam name="TFirst"></typeparam>
        /// <typeparam name="TSecond"></typeparam>
        /// <typeparam name="TThird"></typeparam>
        /// <typeparam name="TReturn"></typeparam>
        /// <param name="cnn"></param>
        /// <param name="sql"></param>
        /// <param name="map"></param>
        /// <param name="param"></param>
        /// <param name="transaction"></param>
        /// <param name="buffered"></param>
        /// <param name="splitOn">The Field we should split and read the second object from (default: id)</param>
        /// <param name="commandTimeout">Number of seconds before command execution timeout</param>
        /// <param name="commandType"></param>
        /// <returns></returns>
        public static IEnumerable<TReturn> QueryAndThrow<TFirst, TSecond, TThird, TReturn>(
            this IDbConnection cnn,
            string sql,
            Func<TFirst, TSecond, TThird, TReturn> map,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            string splitOn = "Id",
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            IEnumerable<TReturn> ret;
            try
            {
                ret = cnn.Query(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>Perform a multi mapping query with 4 input parameters</summary>
        /// <typeparam name="TFirst"></typeparam>
        /// <typeparam name="TSecond"></typeparam>
        /// <typeparam name="TThird"></typeparam>
        /// <typeparam name="TFourth"></typeparam>
        /// <typeparam name="TReturn"></typeparam>
        /// <param name="cnn"></param>
        /// <param name="sql"></param>
        /// <param name="map"></param>
        /// <param name="param"></param>
        /// <param name="transaction"></param>
        /// <param name="buffered"></param>
        /// <param name="splitOn"></param>
        /// <param name="commandTimeout"></param>
        /// <param name="commandType"></param>
        /// <returns></returns>
        public static IEnumerable<TReturn> QueryAndThrow<TFirst, TSecond, TThird, TFourth, TReturn>(
            this IDbConnection cnn,
            string sql,
            Func<TFirst, TSecond, TThird, TFourth, TReturn> map,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            string splitOn = "Id",
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            IEnumerable<TReturn> ret;
            try
            {
                ret = cnn.Query(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>Perform a multi mapping query with 5 input parameters</summary>
        /// <typeparam name="TFirst"></typeparam>
        /// <typeparam name="TSecond"></typeparam>
        /// <typeparam name="TThird"></typeparam>
        /// <typeparam name="TFourth"></typeparam>
        /// <typeparam name="TFifth"></typeparam>
        /// <typeparam name="TReturn"></typeparam>
        /// <param name="cnn"></param>
        /// <param name="sql"></param>
        /// <param name="map"></param>
        /// <param name="param"></param>
        /// <param name="transaction"></param>
        /// <param name="buffered"></param>
        /// <param name="splitOn"></param>
        /// <param name="commandTimeout"></param>
        /// <param name="commandType"></param>
        /// <returns></returns>
        public static IEnumerable<TReturn> QueryAndThrow<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(
            this IDbConnection cnn,
            string sql,
            Func<TFirst, TSecond, TThird, TFourth, TFifth, TReturn> map,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            string splitOn = "Id",
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            IEnumerable<TReturn> ret;
            try
            {
                ret = cnn.Query(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>Perform a multi mapping query with 6 input parameters</summary>
        /// <typeparam name="TFirst"></typeparam>
        /// <typeparam name="TSecond"></typeparam>
        /// <typeparam name="TThird"></typeparam>
        /// <typeparam name="TFourth"></typeparam>
        /// <typeparam name="TFifth"></typeparam>
        /// <typeparam name="TSixth"></typeparam>
        /// <typeparam name="TReturn"></typeparam>
        /// <param name="cnn"></param>
        /// <param name="sql"></param>
        /// <param name="map"></param>
        /// <param name="param"></param>
        /// <param name="transaction"></param>
        /// <param name="buffered"></param>
        /// <param name="splitOn"></param>
        /// <param name="commandTimeout"></param>
        /// <param name="commandType"></param>
        /// <returns></returns>
        public static IEnumerable<TReturn> QueryAndThrow<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn>(
            this IDbConnection cnn,
            string sql,
            Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn> map,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            string splitOn = "Id",
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            IEnumerable<TReturn> ret;
            try
            {
                ret = cnn.Query(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>Perform a multi mapping query with 7 input parameters</summary>
        /// <typeparam name="TFirst"></typeparam>
        /// <typeparam name="TSecond"></typeparam>
        /// <typeparam name="TThird"></typeparam>
        /// <typeparam name="TFourth"></typeparam>
        /// <typeparam name="TFifth"></typeparam>
        /// <typeparam name="TSixth"></typeparam>
        /// <typeparam name="TSeventh"></typeparam>
        /// <typeparam name="TReturn"></typeparam>
        /// <param name="cnn"></param>
        /// <param name="sql"></param>
        /// <param name="map"></param>
        /// <param name="param"></param>
        /// <param name="transaction"></param>
        /// <param name="buffered"></param>
        /// <param name="splitOn"></param>
        /// <param name="commandTimeout"></param>
        /// <param name="commandType"></param>
        /// <returns></returns>
        public static IEnumerable<TReturn> QueryAndThrow
            <TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn>(
                this IDbConnection cnn,
                string sql,
                Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn> map,
                object param = null,
                IDbTransaction transaction = null,
                bool buffered = true,
                string splitOn = "Id",
                int? commandTimeout = null,
                CommandType? commandType = null)
        {
            IEnumerable<TReturn> ret;
            try
            {
                ret = cnn.Query(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        /// <summary>
        /// Perform a multi mapping query with arbitrary input parameters
        /// </summary>
        /// <typeparam name="TReturn">The return type</typeparam>
        /// <param name="cnn"></param>
        /// <param name="sql"></param>
        /// <param name="types">array of types in the record set</param>
        /// <param name="map"></param>
        /// <param name="param"></param>
        /// <param name="transaction"></param>
        /// <param name="buffered"></param>
        /// <param name="splitOn">The Field we should split and read the second object from (default: id)</param>
        /// <param name="commandTimeout">Number of seconds before command execution timeout</param>
        /// <param name="commandType">Is it a stored proc or a batch?</param>
        /// <returns></returns>
        public static IEnumerable<TReturn> QueryAndThrow<TReturn>(
            this IDbConnection cnn,
            string sql,
            Type[] types,
            Func<object[], TReturn> map,
            object param = null,
            IDbTransaction transaction = null,
            bool buffered = true,
            string splitOn = "Id",
            int? commandTimeout = null,
            CommandType? commandType = null)
        {
            IEnumerable<TReturn> ret;
            try
            {
                ret = cnn.Query(sql, types, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
            }
            catch (Exception exception)
            {
                Exception ex = ExceptionManager.Process(cnn, exception);
                AddInformation(ex, sql, types, map, param, transaction, buffered, splitOn, commandTimeout, commandType);
                throw ex;
            }

            return ret;
        }

        private static void AddInformation(Exception ex, CommandDefinition command)
        {
            AddInformation(
                ex,
                command.CommandText,
                command.Parameters,
                command.Transaction,
                command.Buffered,
                command.CommandTimeout,
                command.CommandType);
            ex.Data["Flags"] = command.Flags;
            ex.Data["Pipelined"] = command.Pipelined;
        }

        private static void AddInformation(
            Exception ex,
            string sql,
            object param,
            IDbTransaction transaction,
            int? commandTimeout,
            CommandType? commandType)
        {
            ex.Data["Sql"] = sql;
            ex.Data["CommandTimeout"] = commandTimeout;
            ex.Data["CommandType"] = commandType;
            bool inTransaction = transaction != null;
            ex.Data["InTransaction"] = inTransaction;
            if (inTransaction)
            {
                ex.Data["IsolationLevel"] = transaction.IsolationLevel;
            }

            ex.Data["Parameters"] = param;
        }

        private static void AddInformation(
            Exception ex,
            Type type,
            string sql,
            object param,
            IDbTransaction transaction,
            int? commandTimeout,
            CommandType? commandType)
        {
            AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
            ex.Data["Type"] = type.FullName;
        }

        private static void AddInformation(Exception ex, Type type, CommandDefinition command)
        {
            AddInformation(ex, command);
            ex.Data["Type"] = type.FullName;
        }

        private static void AddInformation<TFirst, TSecond, TReturn>(
            Exception ex,
            string sql,
            Func<TFirst, TSecond, TReturn> map,
            object param,
            IDbTransaction transaction,
            bool buffered,
            string splitOn,
            int? commandTimeout,
            CommandType? commandType)
        {
            AddInformation(ex, sql, param, transaction, buffered, commandTimeout, commandType);
            ex.Data["Map"] = map.ToString();
            ex.Data["SplitOn"] = splitOn;
            AddInformation<TFirst, TSecond, TReturn>(ex);
        }

        private static void AddInformation<T>(
            Exception ex,
            string sql,
            object param,
            IDbTransaction transaction,
            int? commandTimeout,
            CommandType? commandType)
        {
            AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
            ex.Data["T"] = typeof(T).FullName;
        }

        private static void AddInformation<T>(Exception ex, CommandDefinition command)
        {
            AddInformation(ex, command);
            ex.Data["T"] = typeof(T).FullName;
        }

        private static void AddInformation<TFirst, TSecond, TReturn>(
            Exception ex,
            CommandDefinition command,
            Func<TFirst, TSecond, TReturn> map,
            string splitOn)
        {
            AddInformation(ex, command);
            ex.Data["Map"] = map.ToString();
            ex.Data["SplitOn"] = splitOn;
            AddInformation<TFirst, TSecond, TReturn>(ex);
        }

        private static void AddInformation<TFirst, TSecond, TThird, TReturn>(
            Exception ex,
            string sql,
            Func<TFirst, TSecond, TThird, TReturn> map,
            object param,
            IDbTransaction transaction,
            bool buffered,
            string splitOn,
            int? commandTimeout,
            CommandType? commandType)
        {
            AddInformation(ex, sql, param, transaction, buffered, commandTimeout, commandType);
            ex.Data["Map"] = map.ToString();
            ex.Data["SplitOn"] = splitOn;
            AddInformation<TFirst, TSecond, TThird, TReturn>(ex);
        }

        private static void AddInformation<TFirst, TSecond, TThird, TReturn>(
            Exception ex,
            CommandDefinition command,
            Func<TFirst, TSecond, TThird, TReturn> map,
            string splitOn)
        {
            AddInformation(ex, command);
            ex.Data["Map"] = map.ToString();
            ex.Data["SplitOn"] = splitOn;
            AddInformation<TFirst, TSecond, TThird, TReturn>(ex);
        }

        private static void AddInformation<TFirst, TSecond, TThird, TFourth, TReturn>(
            Exception ex,
            string sql,
            Func<TFirst, TSecond, TThird, TFourth, TReturn> map,
            object param,
            IDbTransaction transaction,
            bool buffered,
            string splitOn,
            int? commandTimeout,
            CommandType? commandType)
        {
            AddInformation(ex, sql, param, transaction, buffered, commandTimeout, commandType);
            ex.Data["Map"] = map.ToString();
            ex.Data["SplitOn"] = splitOn;
            AddInformation<TFirst, TSecond, TThird, TFourth, TReturn>(ex);
        }

        private static void AddInformation<TFirst, TSecond, TThird, TFourth, TReturn>(
            Exception ex,
            CommandDefinition command,
            Func<TFirst, TSecond, TThird, TFourth, TReturn> map,
            string splitOn)
        {
            AddInformation(ex, command);
            ex.Data["Map"] = map.ToString();
            ex.Data["SplitOn"] = splitOn;
            AddInformation<TFirst, TSecond, TThird, TFourth, TReturn>(ex);
        }

        private static void AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(
            Exception ex,
            string sql,
            Func<TFirst, TSecond, TThird, TFourth, TFifth, TReturn> map,
            object param,
            IDbTransaction transaction,
            bool buffered,
            string splitOn,
            int? commandTimeout,
            CommandType? commandType)
        {
            AddInformation(ex, sql, param, transaction, buffered, commandTimeout, commandType);
            ex.Data["Map"] = map.ToString();
            ex.Data["SplitOn"] = splitOn;
            AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(ex);
        }

        private static void AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn>(
            Exception ex,
            CommandDefinition command,
            Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn> map,
            string splitOn)
        {
            AddInformation(ex, command);
            ex.Data["Map"] = map.ToString();
            ex.Data["SplitOn"] = splitOn;
            AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn>(ex);
        }

        private static void AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(
            Exception ex,
            CommandDefinition command,
            Func<TFirst, TSecond, TThird, TFourth, TFifth, TReturn> map,
            string splitOn)
        {
            AddInformation(ex, command);
            ex.Data["Map"] = map.ToString();
            ex.Data["splitOn"] = splitOn;
            AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(ex);
        }

        private static void AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn>(
            Exception ex,
            string sql,
            Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn> map,
            object param,
            IDbTransaction transaction,
            bool buffered,
            string splitOn,
            int? commandTimeout,
            CommandType? commandType)
        {
            AddInformation(ex, sql, param, transaction, buffered, commandTimeout, commandType);
            ex.Data["Map"] = map.ToString();
            ex.Data["SplitOn"] = splitOn;
            AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn>(ex);
        }

        private static void AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn>(
            Exception ex,
            string sql,
            Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn> map,
            object param,
            IDbTransaction transaction,
            bool buffered,
            string splitOn,
            int? commandTimeout,
            CommandType? commandType)
        {
            AddInformation(ex, sql, param, transaction, buffered, commandTimeout, commandType);
            ex.Data["Map"] = map.ToString();
            ex.Data["SplitOn"] = splitOn;
            AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn>(ex);
        }

        private static void AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn>(
            Exception ex,
            CommandDefinition command,
            Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn> map,
            string splitOn)
        {
            AddInformation(ex, command);
            ex.Data["Map"] = map.ToString();
            ex.Data["SplitOn"] = splitOn;
            AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn>(ex);
        }

        private static void AddInformation<TReturn>(
            Exception ex,
            string sql,
            Type[] types,
            Func<object[], TReturn> map,
            object param,
            IDbTransaction transaction,
            bool buffered,
            string splitOn,
            int? commandTimeout,
            CommandType? commandType)
        {
            AddInformation(ex, sql, param, transaction, buffered, commandTimeout, commandType);
            ex.Data["Types"] = types.Select(t => t.FullName).ToArray();
            ex.Data["Map"] = map.ToString();
            ex.Data["SplitOn"] = splitOn;
            AddInformation<TReturn>(ex);
        }

        private static void AddInformation(Exception ex, CommandDefinition command, CommandBehavior commandBehavior)
        {
            AddInformation(ex, command);
            ex.Data["CommandBehavior"] = commandBehavior;
        }

        private static void AddInformation(
            Exception ex,
            string sql,
            object param,
            IDbTransaction transaction,
            bool buffered,
            int? commandTimeout,
            CommandType? commandType)
        {
            AddInformation(ex, sql, param, transaction, commandTimeout, commandType);
            ex.Data["Buffered"] = buffered;
        }

        private static void AddInformation<T>(
            Exception ex,
            string sql,
            object param,
            IDbTransaction transaction,
            bool buffered,
            int? commandTimeout,
            CommandType? commandType)
        {
            AddInformation(ex, sql, param, transaction, buffered, commandTimeout, commandType);
            ex.Data["T"] = typeof(T).FullName;
        }

        private static void AddInformation(
            Exception ex,
            Type type,
            string sql,
            object param,
            IDbTransaction transaction,
            bool buffered,
            int? commandTimeout,
            CommandType? commandType)
        {
            AddInformation(ex, sql, param, transaction, buffered, commandTimeout, commandType);
            ex.Data["Type"] = type.FullName;
        }

        private static void AddInformation<TReturn>(Exception ex)
        {
            ex.Data["TReturn"] = typeof(TReturn).FullName;
        }

        private static void AddInformation<TFirst, TSecond, TReturn>(Exception ex)
        {
            ex.Data["TFirst"] = typeof(TFirst).FullName;
            ex.Data["TSecond"] = typeof(TSecond).FullName;
            ex.Data["TReturn"] = typeof(TReturn).FullName;
        }

        private static void AddInformation<TFirst, TSecond, TThird, TReturn>(Exception ex)
        {
            ex.Data["TFirst"] = typeof(TFirst).FullName;
            ex.Data["TSecond"] = typeof(TSecond).FullName;
            ex.Data["TThird"] = typeof(TThird).FullName;
            ex.Data["TReturn"] = typeof(TReturn).FullName;
        }

        private static void AddInformation<TFirst, TSecond, TThird, TFourth, TReturn>(Exception ex)
        {
            ex.Data["TFirst"] = typeof(TFirst).FullName;
            ex.Data["TSecond"] = typeof(TSecond).FullName;
            ex.Data["TThird"] = typeof(TThird).FullName;
            ex.Data["TFourth"] = typeof(TFourth).FullName;
            ex.Data["TReturn"] = typeof(TReturn).FullName;
        }

        private static void AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(Exception ex)
        {
            ex.Data["TFirst"] = typeof(TFirst).FullName;
            ex.Data["TSecond"] = typeof(TSecond).FullName;
            ex.Data["TThird"] = typeof(TThird).FullName;
            ex.Data["TFourth"] = typeof(TFourth).FullName;
            ex.Data["TFifth"] = typeof(TFifth).FullName;
            ex.Data["TReturn"] = typeof(TReturn).FullName;
        }

        private static void AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn>(Exception ex)
        {
            ex.Data["TFirst"] = typeof(TFirst).FullName;
            ex.Data["TSecond"] = typeof(TSecond).FullName;
            ex.Data["TThird"] = typeof(TThird).FullName;
            ex.Data["TFourth"] = typeof(TFourth).FullName;
            ex.Data["TFifth"] = typeof(TFifth).FullName;
            ex.Data["TSixth"] = typeof(TSixth).FullName;
            ex.Data["TReturn"] = typeof(TReturn).FullName;
        }

        private static void AddInformation<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn>(
            Exception ex)
        {
            ex.Data["TFirst"] = typeof(TFirst).FullName;
            ex.Data["TSecond"] = typeof(TSecond).FullName;
            ex.Data["TThird"] = typeof(TThird).FullName;
            ex.Data["TFourth"] = typeof(TFourth).FullName;
            ex.Data["TFifth"] = typeof(TFifth).FullName;
            ex.Data["TSixth"] = typeof(TSixth).FullName;
            ex.Data["TSeventh"] = typeof(TSeventh).FullName;
            ex.Data["TReturn"] = typeof(TReturn).FullName;
        }
    }
}